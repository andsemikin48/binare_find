"""Бинарный поиск
Путь: деление отсортированного списка пополам,
если элемент в середине больше или меньше искомого,
то рекурсивно повторяю поиск, сохраняя при этом индекс изначального массива.
При отсутствии элемента вернуть -1.
При значении больше длины массива поднимаю ошибку.
Обрабатываю ошибку ввода или некорректного значения.
"""
Создаю функцию декоратор для отслеживания времени выполнения алгоритма.
При поиске по массиву в 20 элементов, время выполнения:
 - найденного значения 0.02-0.03 миллисекунды.
 - ненайденного значения 0.04-0.05 миллисекунд.
При поиске по массиву в 100 элементов, время выполнения:
 - найденного значения 0.02-0.03 миллисекунды.
 - ненайденного значения 0.04-0.06 миллисекунд.
Вывод на небольших массивах (до 100 элементов), алгоритм работает одинаково хорошо.
При этом поиск имеющегося значения, даже если это крайний элемент, проходит быстрее,
чем поиск несуществующего значения.
Несколько примеров поиска:
    Результат: 43 (3, 'Время выполнения: 0.022 мс')
    Результат: 277 (22, 'Время выполнения: 0.022 мс')
    Результат: 971 (99, 'Время выполнения: 0.023 мс')
    Результат: 280 (-1, 'Время выполнения: 0.039 мс')
    Результат: 944 (99, 'Время выполнения: 0.023 мс')
    Результат: 4 (0, 'Время выполнения: 0.023 мс')
    Результат: 1001 (-1, 'Время выполнения: 0.031 мс')
    Результат: 967 (-1, 'Время выполнения: 0.044 мс')
Где 1 число - искомое, второе число - индекс элемента в массиве(если -1 значит не найдено),
и третье число время выполнения в миллисекундах.
Создаю линейный список используя цикл for и перебирая каждый элемент в массиве.
Функция так же использует декоратор для проверки времени выполнения.
Примеры выполнения алгоритма на списке из 100 элементов:
    Результат: 2 (0, 'Время выполнения: 0.005 мс')
    Результат: 553 (54, 'Время выполнения: 0.006 мс')
    Результат: 996 (99, 'Время выполнения: 0.007 мс')
    Результат: 1000 (99, 'Время выполнения: 0.007 мс')
    Результат: 1 (-1, 'Время выполнения: 0.014 мс')
    Результат: 500 (-1, 'Время выполнения: 0.015 мс')
    Результат: 990 (-1, 'Время выполнения: 0.014 мс')
    Результат: 1001 (-1, 'Время выполнения: 0.013 мс')
Увеличим массив до 10000 элементов. (Тут я взял не рандомный массив, а от 0 до 10000
то-есть значение должно соответствовать индексу)
Бинарный поиск:
    Результат: 10 (10, 'Время выполнения: 0.078 мс')
    Результат: 15 (15, 'Время выполнения: 0.081 мс')
    Результат: 35 (35, 'Время выполнения: 0.085 мс')
    Результат: 999 (999, 'Время выполнения: 0.082 мс')
    Результат: 1356 (1356, 'Время выполнения: 0.086 мс')
    Результат: 10001 (-1, 'Время выполнения: 0.019 мс')
    Результат: 9999 (9999, 'Время выполнения: 0.087 мс')
Линейный поиск:
    Результат: 10 (10, 'Время выполнения: 0.018 мс')
    Результат: 15 (15, 'Время выполнения: 0.019 мс')
    Результат: 35 (35, 'Время выполнения: 0.020 мс')
    Результат: 999 (999, 'Время выполнения: 0.088 мс')
    Результат: 1356 (1356, 'Время выполнения: 0.124 мс')
    Результат: 9999 (9999, 'Время выполнения: 0.451 мс')
    Результат: 10001 (-1, 'Время выполнения: 0.037 мс')
По этим результатам видно, что при бинарном поиске общее время примерно равно для любых
значений и полностью зависит от размера массива, так как зависит от количества делений
массива.
Линейный поиск зависит от искомого значения, чем оно меньше тем раньше встречается в массиве.
Если же оно расположено в конце массива время увеличивается в разы.